<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Continuous space social distancing for COVID-19 · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../game_of_life_2D_CA/">Game of life</a></li><li><a class="tocitem" href="../rule22_1D_CA/">Rule 22</a></li><li><a class="tocitem" href="../wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../HK/">Hegselmann-Krause opinion dynamics</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Continuous space social distancing for COVID-19</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Continuous space social distancing for COVID-19</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/social_distancing.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Continuous-space-social-distancing-for-COVID-19-1"><a class="docs-heading-anchor" href="#Continuous-space-social-distancing-for-COVID-19-1">Continuous space social distancing for COVID-19</a><a class="docs-heading-anchor-permalink" href="#Continuous-space-social-distancing-for-COVID-19-1" title="Permalink"></a></h1><p>This is a model similar to our <a href="../sir/#SIR-model-for-the-spread-of-COVID-19-1">SIR model for the spread of COVID-19</a>. But instead of having different cities, we let agents move in one continuous space and transfer the disease if they come into contact with one another. This model is partly inspired by <a href="https://www.washingtonpost.com/graphics/2020/world/corona-simulator/">this article</a>, and can complement the SIR graph model. The graph model can model virus transfer between cities, while the current model can be used to study what happens within a city.</p><p>This example serves also as an introduction to using continuous space, modelling billiard-like collisions in that space, and animating the agent motion in the space. Notice that a detailed description of the basics of the model regarding disease spreading exists in the SIR example, and is not repeated here.</p><h2 id="Moving-agents-in-continuous-space-1"><a class="docs-heading-anchor" href="#Moving-agents-in-continuous-space-1">Moving agents in continuous space</a><a class="docs-heading-anchor-permalink" href="#Moving-agents-in-continuous-space-1" title="Permalink"></a></h2><p>Let us first create a simple model were balls move around in a continuous space. We need to create agents that comply with <a href="../../tutorial/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>, i.e. they have a <code>pos</code> and <code>vel</code> fields, both of which are tuples of float numbers.</p><pre><code class="language-julia">using Agents, Random, AgentsPlots, Plots

mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Float64}
    vel::NTuple{2, Float64}
    mass::Float64
end</code></pre><p>The <code>mass</code> field will come in handy later on, when we implement social isolation (i.e. that some agents don&#39;t move and can&#39;t be moved).</p><p>Let&#39;s also initialize a trivial model with continuous space</p><pre><code class="language-julia">const space2d = ContinuousSpace(2; periodic = true, extend = (1, 1))
model = ABM(Agent, space2d, properties = Dict(:dt =&gt; 1.0));</code></pre><p>And add some agents to the model</p><pre><code class="language-julia">const speed = 0.002
Random.seed!(42)
for ind in 1:100
    pos = Tuple(rand(2))
    vel = sincos(2π*rand()) .* speed
    add_agent!(pos, model, vel, 1.0)
end
index!(model)</code></pre><pre><code class="language-none">SQLite.Query(SQLite.Stmt(SQLite.DB(&quot;:memory:&quot;), Ptr{Nothing} @0x00000000054eb958, Dict{Int64,Any}(), 101), Base.RefValue{Int32}(101), Symbol[], Type[], Dict{Symbol,Int64}())</code></pre><p>We took advantage of the functionality of <a href="../../api/#Agents.add_agent!"><code>add_agent!</code></a> that creates the agents automatically. For now all agents have the same absolute <code>speed</code>, and <code>mass</code>. We <code>index!</code> the model, to make finding space neighbors faster.</p><p>The agent step function for now is trivial. It is just <a href="../../api/#Agents.move_agent!"><code>move_agent!</code></a> in continuous space</p><pre><code class="language-julia">agent_step!(agent, model) =  move_agent!(agent, model, model.properties[:dt])</code></pre><pre><code class="language-none">agent_step! (generic function with 1 method)</code></pre><p><code>dt</code> is our time resolution, but we will talk about this more later! Cool, let&#39;s see now how this model evolves.</p><p>TODO: Put this to AgentsPlots</p><pre><code class="language-">function AgentsPlots.plotabm(model::ABM{A, &lt;: ContinuousSpace}, c = x -&gt; &quot;#765db4&quot;, s = x -&gt; 1)
    colors = [c(a) for a in allagents(model)]
    xs = [a.pos[1] for a in allagents(model)]
    ys = [a.pos[2] for a in allagents(model)]
    e = model.space.extend
    p1 = scatter(xs, ys, label=&quot;&quot;, color=colors, xlims=(0,e[1]), ylims=(0,e[2]))
end

anim = @animate for i ∈ 1:100
    p1 = plotabm(model)
    title!(p1, &quot;step $(i)&quot;)
    step!(model, agent_step!, 1)
end
gif(anim, &quot;socialdist1.gif&quot;, fps = 45);
nothing #hide</code></pre><p><img src="socialdist1.gif" alt/></p><p>As you can see the agents move in a straight line in periodic space. There is no interaction yet. Let&#39;s change that.</p><h2 id="Billiard-like-interaction-1"><a class="docs-heading-anchor" href="#Billiard-like-interaction-1">Billiard-like interaction</a><a class="docs-heading-anchor-permalink" href="#Billiard-like-interaction-1" title="Permalink"></a></h2><p>We will model the agents as balls that collide with each other. To this end, we will use two functions from the continuous space API:</p><ol><li><a href="../../api/#Agents.interacting_pairs"><code>interacting_pairs</code></a></li><li><a href="examples/@ref"><code>elastic_collision</code></a></li></ol><p>We want all agents to interact in one go, and we want to avoid double interactions (as instructed by <a href="../../api/#Agents.interacting_pairs"><code>interacting_pairs</code></a>), so we define a model step</p><pre><code class="language-">function model_step!(model)
    for (a1, a2) in interacting_pairs(model, 0.015)
    elastic_collision!(a1, a2, :mass)
    end
end

model = ABM(BallyAgent, space2d, properties = Dict(:dt =&gt; 1.0));

anim = @animate for i ∈ 1:100
    p1 = plotabm(model)
    title!(p1, &quot;step $(i)&quot;)
    step!(model, agent_step!, model_step!, 1)
end
gif(anim, &quot;socialdist2.gif&quot;, fps = 45);
nothing #hide</code></pre><p><img src="socialdist2.gif" alt/></p><p>Alright, this works great so far!</p><div class="admonition"><header class="admonition-header">Agents.jl is not a billiards simulator!</header><div class="admonition-body"><p>Please understand that Agents.jl does not accurately simulate billiard systems. This is the job of Julia packages <a href="https://github.com/JuliaDynamics/HardSphereDynamics.jl">HardSphereDynamics.jl</a> or <a href="https://juliadynamics.github.io/DynamicalBilliards.jl/dev/">DynamicalBilliards.jl</a>. In Agents.jl we only provide an approximating function <code>elastic_collision!</code>. The accuracy of this simulation increases as the time resolution <code>dt</code> decreases, and <strong>only</strong> in the limit <code>dt → 0</code> we reach the accuracy of proper billiard packages.</p></div></div><h2 id="Immovable-agents-1"><a class="docs-heading-anchor" href="#Immovable-agents-1">Immovable agents</a><a class="docs-heading-anchor-permalink" href="#Immovable-agents-1" title="Permalink"></a></h2><p>For the following social distancing example, it will become crucial that some agents don&#39;t move, and can&#39;t be moved (i.e. they stay &quot;isolated&quot;). This is very easy to do with the [<code>elastic_collision!</code>] function, we only have to make some agents have infinite mass</p><pre><code class="language-julia">model2 = ABM(Agent, space2d, properties = Dict(:dt =&gt; 1.0));

Random.seed!(42)
for ind in 1:100
    pos = Tuple(rand(2))
    vel = sincos(2π*rand()) .* speed
    mass = ind &lt; 40 ? Inf : 1.0
    add_agent!(pos, model, vel, mass)
end</code></pre><p>let&#39;s animate this again</p><pre><code class="language-">anim = @animate for i ∈ 1:100
    p1 = plotabm(model2)
    title!(p1, &quot;step $(i)&quot;)
    step!(model2, agent_step!, model_step!, 1)
end
gif(anim, &quot;socialdist3.gif&quot;, fps = 45);
nothing #hide</code></pre><h2 id="Adding-Virus-spread-(SIR)-1"><a class="docs-heading-anchor" href="#Adding-Virus-spread-(SIR)-1">Adding Virus spread (SIR)</a><a class="docs-heading-anchor-permalink" href="#Adding-Virus-spread-(SIR)-1" title="Permalink"></a></h2><p>We now add more functionality to these agents, according to the SIR model (see previous example). They can be infected with a disease and transfer the disease to other agents around them.</p><pre><code class="language-julia">mutable struct PoorSoul &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Float64}
    vel::NTuple{2, Float64}
    mass::Float64
    days_infected::Int  # number of days since is infected
    status::Symbol  # :S, :I or :R
    β::Float64
end</code></pre><p>Here <code>β</code> is the transmission probability, which we choose to make a agent parameter instead of model parameter</p><p>And we also significantly modify the model creation, to have SIR-related parameters</p><pre><code class="language-julia">using DrWatson: @dict

function sir_initiation(;
        infection_period = 30, reinfection_probability = 0.05, isolated = 0,
        interaction_radius = 0.015, dt = 1.0,
        detection_time = 14, death_rate = 0.04, N=1000,
        speed=0.005, initial_infected=N/100, seed=42
    )

    properties = @dict(
        infection_period, reinfection_probability,
        detection_time, death_rate, interaction_radius, dt,
    )
    space = ContinuousSpace(2; periodic = true, extend = (1, 1))
    model = ABM(PoorSoul, space, properties=properties)

    # Add initial individuals
    Random.seed!(seed)
    for ind in 1:N
        pos = Tuple(rand(2))
        vel = sincos(2π*rand()) .* speed
        status = ind ≤ initial_infected ? :I : :S
        mass = ind ≤ isolated ? Inf : 1.0
        β = 0.1rand() + 0.8 # high transmission probability
        add_agent!(pos, model, vel, mass, 0, status, β)
    end

    Agents.index!(model)
    return model
end

sir_model = sir_initiation()</code></pre><pre><code class="language-none">AgentBasedModel with 1000 agents of type PoorSoul
 space: 2-dimensional periodic ContinuousSpace
 scheduler: fastest
 properties: Dict{Symbol,Real}(:infection_period =&gt; 30,:interaction_radius =&gt; 0.015,:detection_time =&gt; 14,:dt =&gt; 1.0,:reinfection_probability =&gt; 0.05,:death_rate =&gt; 0.04)</code></pre><p>To visualize this model, we will use different colors for the infected, recovered and susceptible, leveraging <a href="../../api/#AgentsPlots.plotabm"><code>plotabm</code></a>.</p><pre><code class="language-">sir_colors(a) = a.status == :S ? &quot;black&quot; : a.status == :I ? &quot;red&quot; : &quot;green&quot;

plotabm(sir_model, sir_colors)</code></pre><p>To actually spread the virus, we modify the <code>model_step!</code> function, so that individuals have a probability to transmit the disease as they interact.</p><pre><code class="language-julia">function transmit!(a1, a2)
    # for transmission, only 1 can have the disease (otherwise nothing happens)
    count(a.status == :I, (a1, a2)) ≠ 1 &amp;&amp; return
    infected, healthy = a1.status == :I ? (a1, a2) : (a2, a1)

    rand() ≤ infected.β || return

    if healthy.status == :R
        rand() ≤ model.properties[:reinfection_probability] || return
    end
    healthy.status == :I
end

function model_step!(model)
    r = model.properties[:interaction_radius]
    for (a1, a2) in interacting_pairs(model, r)
        transmit!(a1, a2)
        elastic_collision!(a1, a2, :mass)
    end
end</code></pre><pre><code class="language-none">model_step! (generic function with 1 method)</code></pre><p>Notice that it is not necessary that the transmission interaction radius is the same as the billiard-ball dynamics. We only have them here the same for convenience, but in a real model they will probably differ.</p><p>We also modify the <code>agent_step!</code> function, so that we keep track of how long the agent has been infected, and whether they have to die or not.</p><pre><code class="language-julia">function sir_agent_step!(agent, model)
    move_agent!(agent, model, model.properties[:dt])
    update!(agent)
    recover_or_die!(agent, model)
end

update!(agent) = agent.status == :I &amp;&amp; (agent.days_infected += 1)

function recover_or_die!(agent, model)
    if agent.days_infected ≥ model.properties[:infection_period]
        if rand() ≤ model.properties[:death_rate]
            kill_agent!(agent, model)
        else
            agent.status = :R
            agent.days_infected = 0
        end
    end
end</code></pre><pre><code class="language-none">recover_or_die! (generic function with 1 method)</code></pre><p>Alright, now we can animate this process for default parameters</p><pre><code class="language-">anim = @animate for i ∈ 1:1000
    p1 = plotabm(sir_model)
    title!(p1, &quot;step $(i)&quot;)
    step!(sir_model, sir_agent_step!, sir_model_step!, 1)
end
gif(anim, &quot;socialdist4.gif&quot;, fps = 45);
nothing #hide</code></pre><h2 id="Exponential-spread-1"><a class="docs-heading-anchor" href="#Exponential-spread-1">Exponential spread</a><a class="docs-heading-anchor-permalink" href="#Exponential-spread-1" title="Permalink"></a></h2><pre><code class="language-julia">#TODO</code></pre><h2 id="Social-distancing-1"><a class="docs-heading-anchor" href="#Social-distancing-1">Social distancing</a><a class="docs-heading-anchor-permalink" href="#Social-distancing-1" title="Permalink"></a></h2><p>To battle a virus, there are many ways. If e.g. a vaccine is discovered, then many parameters are affected. For example <code>β</code> will drop dramatically, and so will the spread.</p><p>Lets observe disease spread with different amounts of agent movements. First, agents move with a probability of 0.9.</p><pre><code class="language-">model = model_initiation(N=400,moveprob = 0.9, initial_infected=30);
colordict = Dict(:I=&gt;&quot;red&quot;, :S=&gt;&quot;black&quot;, :R=&gt;&quot;green&quot;)
anim = @animate for i ∈ 1:200
  xs = [a.pos[1] for a in values(model.agents)];
  ys = [a.pos[2] for a in values(model.agents)];
  colors = [colordict[a.status] for a in values(model.agents)];
  p1 = scatter(xs, ys, color=colors, label=&quot;&quot;, xlims=[0,1], ylims=[0, 1], xgrid=false, ygrid=false,xaxis=false, yaxis=false)
  title!(p1, &quot;Day $(i)&quot;)
  step!(model, agent_step!, 1)
end
gif(anim, &quot;social_distancing0.9.gif&quot;, fps = 8);
nothing #hide</code></pre><p><img src="social_distancing0.9.gif" alt/></p><p>And now reduce the movement probability to 0.5.</p><pre><code class="language-">model = model_initiation(N=400,moveprob = 0.5, initial_infected=30);
anim = @animate for i ∈ 1:200
  xs = [a.pos[1] for a in values(model.agents)];
  ys = [a.pos[2] for a in values(model.agents)];
  colors = [colordict[a.status] for a in values(model.agents)];
  p1 = scatter(xs, ys, color=colors, label=&quot;&quot;, xlims=[0,1], ylims=[0, 1], xgrid=false, ygrid=false,xaxis=false, yaxis=false)
  title!(p1, &quot;Day $(i)&quot;)
  step!(model, agent_step!, 1)
end
gif(anim, &quot;social_distancing0.5.gif&quot;, fps = 8);
nothing #hide</code></pre><p><img src="social_distancing0.5.gif" alt/></p><p>The number of infected clearly reduces.</p></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 26 March 2020 13:53">Thursday 26 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
